# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GlobeBuilder
                                 A QGIS plugin
 This plugin adds Globe view
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-01-10
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Gispo Ltd.
        email                : joona@gispo.fi
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import enum
import os.path

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsCoordinateReferenceSystem, QgsProject, QgsPointXY, QgsVectorLayer, QgsFeature, QgsGeometry, \
    QgsFillSymbol, QgsEffectStack, QgsDropShadowEffect, QgsInnerShadowEffect, \
    QgsGeometryGeneratorSymbolLayer, Qgis, QgsRasterLayer

# Import the code for the dialog
from .globe_builder_dialog import GlobeBuilderDialog
# Initialize Qt resources from file resources.py
from .resources import *


class LayerConnectionType(enum.Enum):
    local = 1
    url = 2


class BorderDrawMethod(enum.Enum):
    geometry_generator = "Point"
    buffered_point = "Polygon"


class GlobeBuilder:
    NATURAL_EARTH_BASE_URL = "https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson"
    S2CLOUDLESS_WMTS_URL = "url=https://tiles.maps.eox.at/wmts?SERVICE%3DWMTS%26REQUEST%3DGetCapabilities&contextualWMSLegend=0&crs=EPSG:4326&dpiMode=7&featureCount=10&format=image/jpeg&layers=s2cloudless-2018&styles=default&tileMatrixSet=WGS84"
    LOCAL_DATA_DIR = os.path.join(os.path.dirname(__file__), "data")
    DEFAULT_ORIGIN = {'lat': 42.5, 'lon': 0.5}
    AZIMUTHAL_ORTHOGRAPHIC_PROJ4_STR = '+proj=ortho +lat_0={lat} +lon_0={lon} +x_0=0 +y_0=0 +a=6370997 +b=6370997 +units=m +no_defs'
    EARTH_RADIUS = 6370997
    DEFAULT_NUMBER_OF_SEGMENTS = 64
    DEFAULT_LAYER_CONNECTION_TYPE = LayerConnectionType.local
    DEFAULT_BORDER_DRAW_METHOD = BorderDrawMethod.buffered_point

    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GlobeBuilder_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Globe Builder')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.origin = GlobeBuilder.DEFAULT_ORIGIN

        crs = QgsCoordinateReferenceSystem()
        crs.createFromId(4326)
        self.wgs84 = crs

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GlobeBuilder', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/GlobeBuilder/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Build Globe view'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Globe Builder'),
                action)
            self.iface.removeToolBarIcon(action)

    def calculate_origin(self):
        try:
            if self.dlg.radioButtonCoordinates.isChecked():
                coordinates = tuple(map(lambda c: float(c.strip()), self.dlg.lineEditLonLat.text().split(',')))
                coordinates = {'lon': coordinates[0], 'lat': coordinates[1]}
                self.origin = coordinates

            elif self.dlg.radioButtonGeocoding.isChecked():
                coordinates = self.dlg.get_geocoded_coordinates()
                if not coordinates:
                    raise ValueError(self.tr(u"Make sure to select an item from the Geolocation list"))
                self.origin = coordinates
        except ValueError as e:
            self.origin = GlobeBuilder.DEFAULT_ORIGIN
            self.iface.messageBar().pushMessage(self.tr(u"Error occurred while parsing center of the globe"),
                                                "{}: {}".format(self.tr("uTraceback"), e),
                                                level=Qgis.Warning, duration=4)

    def load_data(self):
        existing_layer_names = self.get_existing_layer_names()
        s2_cloudless_layer_name = self.tr(u'S2 Cloudless 2018')
        if self.dlg.checkBoxS2cloudless.isChecked() and s2_cloudless_layer_name not in existing_layer_names:
            s2_layer = QgsRasterLayer(GlobeBuilder.S2CLOUDLESS_WMTS_URL, s2_cloudless_layer_name, "wms")
            if s2_layer.isValid():
                QgsProject.instance().addMapLayer(s2_layer)
            else:
                self.iface.messageBar().pushMessage(self.tr(u"Could not add Sentinel 2 Cloudless layer"),
                                                    level=Qgis.Warning, duration=4)
        ne_data = {}
        if self.dlg.checkBoxCountries.isChecked():
            ne_data[self.tr(u'Countries')] = 'ne_110m_admin_0_countries.geojson'
        if self.dlg.checkBoxGraticules.isChecked():
            ne_data[self.tr(u'Graticules')] = 'ne_10m_graticules_30.geojson'
        len(ne_data) and self.load_natural_eath_data(ne_data)

    def load_natural_eath_data(self, ne_data):
        # TODO: resolution
        existing_layer_names = self.get_existing_layer_names()

        connection_type = LayerConnectionType(
            QSettings().value("/GlobeBuilder/layerConnectionType", GlobeBuilder.DEFAULT_LAYER_CONNECTION_TYPE.value,
                              type=int))

        if connection_type == LayerConnectionType.local:
            root = GlobeBuilder.LOCAL_DATA_DIR
        else:
            root = GlobeBuilder.NATURAL_EARTH_BASE_URL

        for name, source in ne_data.items():
            if name not in existing_layer_names:
                layer = self.iface.addVectorLayer(os.path.join(root, source), name, "ogr")
                if layer is None:
                    layer = self.iface.addVectorLayer(os.path.join(GlobeBuilder.LOCAL_DATA_DIR, source), name, "ogr")
                if layer is None:
                    self.iface.messageBar().pushMessage(
                        self.tr(u"Could not load Natural Earth layer '{}'".format(name)),
                        level=Qgis.Warning, duration=3)
                else:
                    layer.setName(name)

    def change_project_projection_to_azimuthal_orthographic(self):
        # Change to wgs84 to activate the changes in origin
        QgsProject.instance().setCrs(self.wgs84)
        proj4_string = GlobeBuilder.AZIMUTHAL_ORTHOGRAPHIC_PROJ4_STR.format(**self.origin)
        crs = QgsCoordinateReferenceSystem()
        crs.createFromProj4(proj4_string)
        QgsProject.instance().setCrs(crs)

    def change_background_color(self, color=QtCore.Qt.black):
        new_background_color = QColor(color)

        # Write it to the project (will still need to be saved!)
        instance = QgsProject.instance()
        instance.writeEntry("Gui", "/CanvasColorRedPart", new_background_color.red())
        instance.writeEntry("Gui", "/CanvasColorGreenPart", new_background_color.green())
        instance.writeEntry("Gui", "/CanvasColorBluePart", new_background_color.blue())

        # And apply for the current session
        self.iface.mapCanvas().setCanvasColor(new_background_color)
        self.iface.mapCanvas().refresh()

    @staticmethod
    def get_existing_layer_names():
        return [layer.name() for layer in QgsProject.instance().mapLayers().values()]

    # noinspection PyArgumentList
    @staticmethod
    def set_border_styles(layer, draw_method):
        renderer = layer.renderer()
        sym = renderer.symbol()

        props = {'color': 'blue'}
        fill_symbol = QgsFillSymbol.createSimple(props)

        # Assign effects
        effect_stack = QgsEffectStack()
        effect_stack.appendEffect(QgsDropShadowEffect.create({'color': 'white'}))
        effect_stack.appendEffect(QgsInnerShadowEffect.create({'color': 'white'}))

        fill_symbol.symbolLayers()[0].setPaintEffect(effect_stack)
        if draw_method == BorderDrawMethod.buffered_point:
            renderer.setSymbol(fill_symbol)
        else:
            geom_generator_sl = QgsGeometryGeneratorSymbolLayer.create({
                'SymbolType': 'Fill',
                'geometryModifier': 'buffer($geometry, {:d})'.format(GlobeBuilder.EARTH_RADIUS)
            })
            geom_generator_sl.setSubSymbol(fill_symbol)
            sym.changeSymbolLayer(0, geom_generator_sl)

        layer.triggerRepaint()
        return layer

    def add_borders(self):
        layer_name = self.tr(u"Halo")

        instance = QgsProject.instance()
        [instance.removeMapLayer(lyr.id()) for lyr in instance.mapLayersByName(layer_name)]

        draw_method = BorderDrawMethod(
            QSettings().value("/GlobeBuilder/borderDrawMethod", GlobeBuilder.DEFAULT_BORDER_DRAW_METHOD.value,
                              type=str))
        proj4_string = GlobeBuilder.AZIMUTHAL_ORTHOGRAPHIC_PROJ4_STR.format(**self.origin)
        # Block signals required to prevent the pop up asking about the crs change
        self.iface.mainWindow().blockSignals(True)
        layer = QgsVectorLayer(draw_method.value, layer_name, "memory")
        crs = layer.crs()
        crs.createFromProj4(proj4_string)
        layer.setCrs(crs)
        self.iface.mainWindow().blockSignals(False)

        feature = QgsFeature()
        geom = QgsGeometry.fromPointXY(QgsPointXY(self.origin['lat'], self.origin['lon']))
        if draw_method == BorderDrawMethod.buffered_point:
            geom = geom.buffer(GlobeBuilder.EARTH_RADIUS, GlobeBuilder.DEFAULT_NUMBER_OF_SEGMENTS)
        feature.setGeometry(geom)
        provider = layer.dataProvider()
        layer.startEditing()
        provider.addFeatures([feature])
        layer.commitChanges()

        # Assign styles and add to toc
        self.set_border_styles(layer, draw_method)
        instance.addMapLayer(layer)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start:
            self.first_start = False
            self.dlg = GlobeBuilderDialog()
            self.dlg.lineEditLonLat.setText("{lon}, {lat}".format(**GlobeBuilder.DEFAULT_ORIGIN))

        # Dialog options
        self.dlg.on_radioButtonCoordinates_toggled(self.dlg.radioButtonCoordinates.isChecked())
        self.dlg.on_radioButtonGeocoding_toggled(self.dlg.radioButtonGeocoding.isChecked())

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            self.load_data()
            self.calculate_origin()
            self.change_background_color()
            self.change_project_projection_to_azimuthal_orthographic()
            self.add_borders()
